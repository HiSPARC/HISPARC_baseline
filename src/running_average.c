/*
 * ============================================================================
 *
 *       Filename:  running_average.c
 *
 *    Description:  This program implements a running average to still be able
 *                  to determine the average even if we have to few points
 *                  before the spike
 *
 *        Version:  2.0
 *        Created:  16-05-2014 15:06:53
 *       Compiler:  gcc
 *
 *         Author:  Jorian van Oostenbrugge
 *
 * ============================================================================
 */

#include <stdio.h>
#include <math.h>
#include <limits.h>

#define WIDTH 100
#define SIZE 1934
#define STDEVLIMIT 3
#define MAXAVERAGE 245

// Declare functions
double average(int begin, int end, int array[]);
int runningAverage(int start, int end, int array[], int size);
struct sequence calculateProperties(int begin, int end, int array[], int size);
double stdev(int begin, int end, int array[], const double average);

// Declare struct to hold array properties
struct sequence
{
    double average;
    double stdev;
};


int
main (void)
{
    int array[SIZE] = {208,238,312,427,519,539,524,489,449,413,
        386,365,357,347,328,317,299,285,274,279,271,258,251,243,
        239,245,238,237,228,223,218,217,214,214,214,214,211,216,
        214,214,211,213,212,211,205,209,204,208,209,216,213,214,
        208,208,208,207,204,209,205,207,202,203,204,215,218,217,
        212,215,208,206,206,205,201,203,201,204,201,202,199,200,
        198,203,199,203,202,203,200,203,198,205,199,203,197,202,
        199,202,199,204,199,203,203,206,203,203,207,218,215,212,
        207,211,205,205,202,202,200,203,200,201,200,205,199,202,
        199,201,200,200,200,202,199,203,200,197,200,202,201,201,
        200,203,199,201,199,201,199,198,200,204,199,202,199,201,
        200,201,198,201,200,201,198,204,199,198,197,199,196,199,
        198,201,197,203,198,200,197,202,197,198,198,198,197,201,
        197,198,198,200,196,199,199,200,196,198,198,200,196,201,
        195,200,197,200,198,197,197,201,197,199,197,199,195,199,
        197,199,197,200,198,203,197,199,198,203,197,201,197,200,
        198,201,195,198,195,199,196,202,199,198,199,201,198,201,
        199,200,198,199,198,200,199,199,195,202,197,199,197,201,
        196,201,199,201,197,197,197,200,195,201,197,200,200,201,
        211,232,236,232,222,221,209,209,202,206,201,204,201,202,
        200,201,197,200,198,200,199,202,197,201,198,202,197,201,
        199,202,198,202,199,201,199,201,198,201,197,200,198,199,
        197,202,197,203,199,199,198,201,197,199,198,201,197,203,
        197,202,198,201,198,199,198,200,198,203,198,201,197,199,
        196,200,197,200,198,201,197,199,196,199,198,203,198,200,
        198,199,199,201,196,200,197,198,199,202,196,201,199,203,
        198,201,197,198,199,201,198,201,198,199,197,203,197,200,
        199,202,202,206,201,204,200,200,199,203,197,201,200,204,
        199,201,198,201,198,203,197,201,198,200,197,203,198,201,
        198,200,197,198,197,202,197,201,196,198,197,202,199,201,
        199,198,196,200,199,202,197,202,195,198,197,202,199,202,
        199,201,198,199,198,199,197,202,197,199,196,201,196,198,
        200,202,199,203,198,200,199,200,198,199,198,202,197,201,
        197,202,198,200,198,201,198,200,199,202,198,200,198,201,
        200,201,197,201,198,200,198,201,199,200,197,201,197,199,
        197,202,198,202,197,203,199,201,196,203,199,201,195,201,
        197,200,199,199,196,200,197,203,197,199,198,201,198,201,
        197,200,198,197,196,201,197,201,197,200,199,201,196,203,
        197,199,200,200,196,200,199,203,198,200,198,202,199,201,
        197,200,198,202,199,201,198,199,197,202,199,199,197,202,
        198,202,198,199,196,200,199,200,198,200,197,202,197,200,
        198,200,198,199,198,203,197,200,197,200,197,202,198,200,
        196,201,200,201,200,201,199,201,197,199,198,202,197,200,
        197,202,197,202,198,199,198,200,198,199,197,203,197,203,
        197,198,197,202,197,200,196,199,197,201,195,201,198,202,
        197,201,196,200,197,200,198,202,199,199,198,201,196,199,
        197,202,199,203,199,200,198,201,198,203,197,200,198,199,
        197,199,198,202,198,200,198,199,199,201,198,200,197,200,
        197,199,196,202,199,199,199,200,196,198,198,201,197,202,
        196,200,198,202,199,203,197,197,199,201,197,200,199,201,
        196,199,198,200,199,203,202,201,199,200,198,198,198,200,
        199,199,197,201,198,200,199,200,198,200,198,202,197,199,
        198,199,198,201,197,200,199,203,196,199,199,200,197,199,
        196,200,198,199,198,201,197,201,199,202,196,200,196,203,
        197,199,198,203,199,201,199,201,197,202,197,200,198,201,
        197,201,199,201,196,200,198,200,201,202,197,201,199,202,
        200,202,195,199,200,200,198,201,197,199,198,202,197,202,
        198,200,197,201,199,201,198,202,197,199,197,199,196,201,
        197,202,199,201,198,201,197,201,197,201,198,199,198,199,
        195,200,196,202,199,199,197,199,199,202,198,200,197,201,
        197,199,197,201,197,201,196,199,198,201,199,204,199,201,
        199,199,198,199,198,200,196,201,197,203,199,201,197,199,
        198,202,196,204,198,198,201,201,196,198,197,200,199,201,
        200,199,197,200,198,201,198,197,198,203,197,200,198,201,
        198,198,197,201,198,196,198,199,198,201,198,202,194,201,
        197,199,197,197,200,201,199,203,199,201,198,201,196,203,
        200,200,197,198,198,200,198,200,199,200,197,200,197,198,
        198,200,198,202,199,199,200,200,197,199,198,200,198,203,
        199,201,200,200,197,200,199,201,200,203,197,198,198,200,
        198,200,196,200,197,202,195,200,198,200,199,200,199,202,
        199,202,197,199,197,200,199,199,199,200,198,200,199,201,
        198,198,199,202,198,201,196,200,197,201,199,202,197,202,
        198,202,197,201,199,200,197,202,197,199,200,203,197,201,
        197,201,199,203,197,201,198,201,199,202,197,203,198,201,
        196,201,197,201,198,200,198,200,198,200,199,201,199,200,
        196,201,197,201,200,200,198,200,199,200,199,201,197,201,
        197,201,196,202,197,202,198,201,198,201,198,201,198,201,
        197,201,197,199,199,200,197,201,197,199,198,198,197,199,
        197,200,200,199,195,200,198,200,198,203,199,201,197,200,
        197,201,200,201,199,202,197,198,200,202,196,197,198,200,
        198,200,198,200,200,200,198,201,197,200,199,202,198,203,
        199,201,196,200,200,199,198,200,198,200,198,200,199,202,
        197,203,199,201,197,201,199,202,199,199,197,202,199,200,
        198,201,199,203,198,200,200,200,197,202,197,201,198,201,
        198,200,197,202,198,203,198,202,200,201,198,200,199,200,
        196,200,199,200,198,202,198,199,197,200,198,200,198,201,
        199,202,199,201,199,200,199,203,197,201,196,202,197,201,
        198,200,198,201,197,201,196,200,198,201,196,202,199,200,
        198,202,199,201,197,202,199,201,198,199,200,200,198,203,
        198,201,199,202,201,200,198,201,197,201,196,201,199,201,
        200,202,199,200,199,201,198,201,200,201,198,199,198,201,
        199,202,198,199,199,202,200,201,199,202,199,202,198,201,
        200,201,199,202,197,202,198,201,199,200,199,201,198,201,
        199,201,199,200,198,202,199,201,199,201,197,199,200,202,
        198,202,200,201,198,203,200,200,198,201,198,199,199,200,
        198,203,199,203,199,201,197,200,199,204,197,204,198,199,
        200,202,198,201,200,201,201,203,199,199,200,201,198,202,
        199,200,197,202,199,201,199,201,197,200,199,203,198,200,
        199,200,199,203,198,201,198,201,198,203,199,200,199,200,
        199,202,198,202,199,202,198,203,198,199,198,200,197,200,
        200,201,199,203,197,202,198,199,200,201,197,201,199,203,
        200,202,198,202,199,203,198,203,197,201,200,193,199,202,
        200,206,197,203,200,202,201,202,199,202,198,201,199,201,
        198,202,199,204,199,201,200,200,197,203,199,200,198,202,
        199,200,200,202,199,203,198,201,200,201,197,203,198,201,
        198,201,200,202,200,203,199,200,200,201,198,201,200,202,
        196,198,198,200,198,200,197,204,198,201,198,202,198,201,
        199,200,199,203,197,200,198,202,198,201,198,203,199,203,
        198,199,200,203,199,200,200,202,199,201,198,201,198,203,
        197,199,200,202,199,201,197,201,197,201,199,199,199,202,
        198,200,197,202,198,201,199,203,198,205,198,201,198,201,
        199,202,196,200,198,202,199,200,199,202,198,201,198,200,
        197,201,200,201,199,202,199,202,198,201,198,201,197,201,
        199,201,198,200,198,201,198,200,198,202,199,200,198,202,
        198,201,199,202,198,201,199,203,199,203,198,200,198,202,
        200,202,196,202,197,201,197,202,197,202,199,200,198,203,
        201,201,196,201,199,200,198,200,198,201,199,202,197,200,
        197,200,198,200,198,201,198,201,200,203,199,201,198,202,
        199,201,198,201,200,200,198,200,199,202,199,201,198,202,
        200,201,198,202,198,203,198,201,199,201,197,201,199,201,
        199,203,197,199,201,202,199,202,197,201,199,200,198,201,
        199,201,197,201,198,202,198,203,196,202,200,201,199,199,
        198,203,198,202,198,201,198,200,199,202,197,202,199,199,
        199,202,198,201,198,201,199,202,199,201,199,200,201,199,
        200,198,199,203,197,203,200,199,198,201,198,201,199,201,
        197,203,197,200,198,202,197,201,200,200,199,201,198,202,
        198,202,197,202,199,203,200,204,197,201,199,202,196,201,
        197,204,199,203,198,203,198,200,200,200,197,202,198,203,
        197,199,200,202,199,200,199,202,198,199,199,202,199,201,
        196,199,197,200,198,201,197,200,198,201,196,199,199,202,
        198,203,198,201,198,199,200,203,197,203,197,201,199,201,
        200,203,198,203,199,201,198,201,197,201,199,202,199,200,
        198,201,199,202,198,200,195,200,198,199,199,199,199,202,
        198,201,197,201,200,202,195,203,199,201,199,203,197,202,
        198,201,199,202,198,200,199,200,197,202,198,200,198,201,
        199,203,198,203,197,201,197,200,199,201,198,200,201,202,
        200,200,198,199,197,202,199,200,200,198,200,203,197,201,
        198,202,197,204,198,201,199,201,199,200,197,203,196,202,
        197,200,198,198,198,199};
               
    printf("Value = %i\n", runningAverage(0, WIDTH, array, SIZE));
}


/* 
 * Calculate properties of array: average of elements from begin to end and
 * the standard deviation and return a struct with these properties
 */

struct sequence
calculateProperties(int begin, int end, int array[], int size)
{
    struct sequence properties;
    
    // Calculate average of array
    properties.average = average(begin, end, array);

    // Calculate sample standard deviation of array
    properties.stdev = stdev(begin, end, array, properties.average);

    return properties;
}


/*
 * Calcuate the average of the elements of array[] from begin to end
 */

double
average(int begin, int end, int array[])
{
    double sum = 0;
    double average;
    
    // Calculate the average
    for (int i = begin; i < end; i++)
    {
        sum += array[i];
    }

    average = sum / WIDTH;
    
    return (average);
}


/* 
 * Calculate the standard deviation of the elements of array[] from 
 * begin to end using average
 */

double
stdev(int begin, int end, int array[], const double average)
{
    double total = 0;
    double variance;
    double stdev;

    // Calculate the variance
    for (int i = begin; i < end; i++)
    {
        // Calculate sum of squares
        total += pow((array[i] - average), 2.0);
    }
    
    // Average sum of squares
    variance = total / WIDTH;

    stdev = sqrt(variance);

    return (stdev);
}


/*
 * Determine the starting point for determining the baseline the start in
 * combination with the end define the width of the "sequence" i.e. an array
 * which starts at start and ends at end - 1. This function compares two
 * such sequences and stop until it finds a sequence with a smoother baseline
 * compared to the next sequence. If the exists no such sequence an error
 * with value INT_MAX is returned
 */

int
runningAverage(int start, int end, int array[], int size)
{
    int nextStart, nextEnd;
    struct sequence currentSequence, nextSequence;

    // Do not exceed array else shift sequence back to fall exactly in array
    if ((end + WIDTH) > size)
    {
        nextStart = (start + WIDTH) - ((end + WIDTH) - size);
        nextEnd = size;
    }
    else
    {
        nextStart = start + WIDTH;
        nextEnd = end + WIDTH;
    }

    // Set sequences
    currentSequence = calculateProperties(start, end, array, SIZE);
    nextSequence = calculateProperties(nextStart, nextEnd, array, SIZE);

    // Base cases i.e. when to end the recursion
    if (end == size)
    {
        // Array exactly size of sequence
        // if it falls below limits return start else return error
        if (currentSequence.average < MAXAVERAGE && 
              currentSequence.stdev < STDEVLIMIT)
            return start;
        else
            return (INT_MAX);
    }
    else if (currentSequence.stdev < STDEVLIMIT)
    {
        // Stdev falls within limit so first check if theere is no saturation
        if (currentSequence.average < MAXAVERAGE && 
            nextSequence.average < MAXAVERAGE)
        {
            if (currentSequence.stdev < nextSequence.stdev)
            {
                // A lower stdev i.e. a smoother line is more important than a 
                // low average so return
                return (start);
            }
            else if (currentSequence.stdev == nextSequence.stdev)
            {
                // Because both stdevs are equal we want the lowest average
                if (currentSequence.average < nextSequence.average)
                    return (start);
            }
        }
        else if (nextSequence.average > MAXAVERAGE)
        {
            // Encountered saturation of the adc if this is the last sequence 
            // of the array return an error INT_MAX because all preceeding
            // sequences also had problems else if it is not the end of the
            // array go on because chances are great we comes across a better
            // sequence
            if (nextEnd == size)
            {
                if (currentSequence.average < MAXAVERAGE)
                    return (start);
                else
                    return (INT_MAX);
            }
        }
    }
    else if (nextEnd == size)
    {
        // A whole number of sequences fits in the array and the last sequence 
        // looks like the best baseline, so if it falls below all limits return
        // the startvalue else return error
        if (nextSequence.average < MAXAVERAGE &&
              nextSequence.stdev < STDEVLIMIT)
            return (nextStart);
        else
            return (INT_MAX);
    }

    start += WIDTH;
    end += WIDTH;

    return (runningAverage(start, end, array, size));
}
